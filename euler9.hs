{-
A Pythagorean triplet is a set of three natural numbers, a < b < c, for
which, a^(2) + b^(2) = c^(2)

ie: 3^(2) + 4^(2) = 9 + 16 = 25 = 5^(2)

find one Pythagorean triplet for which a + b + c = 1000

a = k (2mn) : b = k(m^2 - n^2) : c = k(m^2 + n^2)
where m, n, and k are positive integers with m > n.

a= 2n + 1 : b=2n(n + 1) : c = 2n(n + 1) + 1
                          -
1000 = 2n + 1 + 2n(n+1) + 2n(n+1) +1

x = c - b, y = c - a, z = a + b - c and a = x + z, b = y + z, c = x + y + z
and r = z/2 , where x, y, and z are the three sides of the triple and r is the
radius of the inscribed circle.

Pythagorean triples can then be generated by choosing any even integer z.

x and y are any two factors of z2 / 2.

-}

import Data.List

flrSqrt ::  (Integral b, Integral a) => a -> b
flrSqrt n = floor . sqrt.fromIntegral $ n

-- factor any given number, dont include the sqrt
factors ::  (Integral t) => t -> [t]
factors n = 1 : [x | x <- [2..n], n `mod` x == 0, x /= flrSqrt n ]

tailFlip [] = []
tailFlip ls = reverse.tail $ ls

doubleTF = tailFlip.tailFlip

-- Make tuples from the factor list
factTup ::  [a] -> [(a, a)]
factTup [] = []
factTup ts = (head ts, last ts) : factTup (doubleTF ts)

-- Different Factor Forms
--pyA ::  (Num a) => a -> (a, a) -> a

pyA ::  (Num a) => a -> (a, a) -> a
pyA z xy = (+ z).fst $ xy
pyB ::  (Num a) => a -> (a, a) -> a
pyB z xy = snd xy + z
pyC ::  (Num b) => b -> (b, b) -> b
pyC z xy = fst xy + snd xy + z

--tupZ :: (Integral a, RealFrac a) => a -> [(a, a)]
tupZ = factTup.factors.floor.(/ 2).(^ 2)

--foo :: (Integral a, RealFrac a) => a -> [[(a, a)]]
foo z = [ tupZ x | x <- [2,4..z]]

--moo ::  (Integral a, RealFrac a) => a -> [(a, a, a)]
--moo z = [ (pyA z $ head xy, pyB z $ head xy, pyC z $ head xy) | xy <- foo z]
--moo z = [ pyA z $ head xy | xy <- foo z]




{-

--foo ::  (Integral a, Integral b, Fractional a) => a -> [(b, b)]
--foo x = factTup.factors.floor.(/ 2) $ x^2


this all didnt work even thought it did create some triples


evn ::  (Num a) => a -> a
evn n = (* 2) n

formA ::  (Num a) => a -> a
formA a = evn a + 1
formB ::  (Num a) => a -> a
formB b = evn b * (b + 1)
formC ::  (Num a) => a -> a
formC c = formB c + 1

foo ::  [(Integer, Integer, Integer)]
foo = [ ( formA x, formB x, formC x) | x <- [1..1000], formA x + formB x + formC x <= 1000 ]


formA1 ::  (Num a) => a -> a
formA1 a = evn a
formB1 ::  (Num a) => a -> a
formB1 b = b^2 - 1
formC1 ::  (Num a) => a -> a
formC1 c = c^2 - 1

foo1 ::  [(Integer, Integer, Integer)]
foo1 = [ ( formA1 x, formB1 x, formC1 x) | x <- [1..1000], formA1 x + formB1 x + formC1 x <= 1000]


-}
