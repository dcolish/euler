{-
A Pythagorean triplet is a set of three natural numbers, a < b < c, for
which, a^(2) + b^(2) = c^(2)
    ie: 3^(2) + 4^(2) = 9 + 16 = 25 = 5^(2)

find one Pythagorean triplet for which a + b + c = 1000

    x = c - b,
    y = c - a,
    z = a + b - c
and
    a = x + z,
    b = y + z,
    c = x + y + z
and r = z/2 , where x, y, and z are the three sides of the triple and r is the
radius of the inscribed circle.

Pythagorean triples can then be generated by choosing any even integer z.
x and y are any two factors of z2 / 2.
-}

import Data.List

-- factor any given number, dont include the sqrt
factors ::  Integer -> [Integer]
factors n = 1 : [x | x <- [2..n], n `mod` x == 0, x*x /= n ]

-- tail then reverse a list
tailFlip ::  [a] -> [a]
tailFlip [] = []
tailFlip ls = reverse.tail $ ls

-- tail and reverse a list twice to drop the first and last elements
doubleTF ::  [a] -> [a]
doubleTF = tailFlip.tailFlip

-- Make tuples from the factor list
factTup ::  [a] -> [(a, a)]
factTup [] = []
factTup ts = (head ts, last ts) : factTup (doubleTF ts)

-- Transform the tuple xy and radii z into a triple list
pyth ::  (Num a) => a -> (a, a) -> [a]
pyth z xy = pyA z xy : pyB z xy : pyC z xy : []

-- Different Factor Forms
-- a = x + z
pyA ::   (Num a) => a -> (a, a) -> a
pyA z xy = (+ z).fst $ xy

-- b = y + z
pyB ::   (Num a) => a -> (a, a) -> a
pyB z xy = snd xy + z

-- x + y + z
pyC ::   (Num a) => a -> (a, a) -> a
pyC z xy = fst xy + snd xy + z

-- generate tuple pairs
tupZ ::  Integer -> [(Integer, Integer)]
tupZ = factTup.factors.(`div` 2).(^ 2)

-- list of list of triples
--foo ::  Integer -> [[Integer]]
foo z = [ mapP x | x <- [2,4..z] ]


--mapP ::  Integer -> [[Integer]]
mapP r
    | even r = map(pyth r).tupZ $ r
    | otherwise = error "r must be even"

-- filter our list
tripFilter ::  Integer -> [[Integer]]
tripFilter z = filter((== 1000). \x -> sum x) $ concat $ foo z

--fixMaps [] = []
--fixMaps [t] = t
--fixMaps (t:ts) = head t : fixMaps (tail ts)

main = print $ product.head $ tripFilter 1000
